{-# LANGUAGE DeriveDataTypeable, DeriveGeneric #-}

module Messages where

import Data.Typeable (Typeable)
import GHC.Generics (Generic)
import Data.Binary (Binary)
import Control.Distributed.Process
import qualified Data.ByteString.Char8 as B
import qualified Data.ByteString.Lazy.Char8 as L
import Data.Binary(decode,encode)

type DataNodeId = Int
type BlockId = Int
type Host = String
type Port = String
type LocalPosition = (DataNodeId, BlockId)
type RemotePosition = (ProcessId, BlockId)
type RemoteAddress = (Port,BlockId)

type BlockCount = Int
type FileData = L.ByteString


-- Block size in bytes. For now, very small for testing purposes
blockSize :: Integer
blockSize = 1048576 --1MB

<<<<<<< HEAD
data ClientConnection = Response ProcessId
  deriving (Typeable, Generic)

=======
>>>>>>> STM
data HandShake = HandShake
  { dataNodePid    :: ProcessId
  , dataNodeUid    :: Int
  , dataNodeBlocks :: [BlockId]
  , proxyPort      :: Port
  }
  | WhoAmI (SendPort DataNodeId)
  deriving (Typeable, Generic)

<<<<<<< HEAD
data ProxyToNameNode = ListFilesP (SendPort [FilePath])
                    | ReadP FilePath (SendPort (ClientRes [RemoteAddress]))
                    | WriteP FilePath BlockCount (SendPort (ClientRes [RemoteAddress]))
                    | Shutdown
  deriving (Typeable, Generic)

data ClientToNameNode = ListFiles
                      | Read FilePath
                      | Write FilePath BlockCount
=======
data ClientReq = ListFiles (SendPort (ClientRes [FilePath]))
               | Read FilePath (SendPort (ClientRes [RemotePosition]))
               | Write FilePath BlockCount (SendPort (ClientRes [RemotePosition]))
               | Shutdown
>>>>>>> STM
  deriving (Typeable, Generic)

data ProxyToClient = FilePaths [FilePath]
                   | ReadAddress (ClientRes [RemoteAddress])
                   | WriteAddress (ClientRes [RemoteAddress])
                   | FileBlock FileData
  deriving (Typeable, Generic,Show)


type ClientRes a = Either ClientError a

data ClientError = InvalidPathError
                 | FileNotFound
                 | InconsistentNetwork
  deriving (Typeable, Generic, Show)

<<<<<<< HEAD
data ProxyToDataNode = CDNReadP BlockId (SendPort FileData)
            | CDNWriteP BlockId FileData
            | CDNDeleteP BlockId
  deriving (Typeable, Generic)

data ClientToDataNode = CDNRead BlockId
                      | CDNWrite BlockId FileData
                      | CDNDelete BlockId
  deriving (Typeable, Generic, Show)

data IntraNetwork = Repl BlockId [ProcessId]
  deriving (Typeable, Generic)
=======
data CDNReq = CDNRead BlockId (SendPort FileData)
            | CDNWrite BlockId FileData
            | CDNDelete BlockId
            | CDNRep BlockId [ProcessId]
  deriving (Typeable, Generic, Show)
>>>>>>> STM

data BlockReport = BlockReport DataNodeId [BlockId]
  deriving (Typeable, Generic)

instance Binary ProxyToNameNode
instance Binary ProxyToClient
instance Binary ProxyToDataNode

instance Binary ClientToNameNode
instance Binary ClientToDataNode

instance Binary IntraNetwork
instance Binary HandShake
instance Binary ClientError
instance Binary BlockReport

{-instance Serialize ProxyToClient
instance Serialize ClientToNameNode
instance Serialize ClientToDataNode
instance Serialize ClientError-}

toByteString :: Binary a => a -> L.ByteString
toByteString = encode

fromByteString :: Binary a => L.ByteString -> a
fromByteString = decode
